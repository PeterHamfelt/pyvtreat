window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "vtreat", "modulename": "vtreat", "qualname": "", "type": "module", "doc": "<p>This<a href=\"https://github.com/WinVector/pyvtreat\">https://github.com/WinVector/pyvtreat</a> is the Python version of the vtreat data preparation system\n(also available as an R package<a href=\"https://winvector.github.io/vtreat/\">https://winvector.github.io/vtreat/</a>.</p>\n\n<p>vtreat is a DataFrame processor/conditioner that prepares\nreal-world data for supervised machine learning or predictive modeling\nin a statistically sound manner.</p>\n\n<p>vtreat takes an input DataFrame\nthat has a specified column called \"the outcome variable\" (or \"y\")\nthat is the quantity to be predicted (and must not have missing\nvalues).  Other input columns are possible explanatory variables\n(typically numeric or categorical/string-valued, these columns may\nhave missing values) that the user later wants to use to predict \"y\".\nIn practice such an input DataFrame may not be immediately suitable\nfor machine learning procedures that often expect only numeric\nexplanatory variables, and may not tolerate missing values.</p>\n\n<p>To solve this, vtreat builds a transformed DataFrame where all\nexplanatory variable columns have been transformed into a number of\nnumeric explanatory variable columns, without missing values.  The\nvtreat implementation produces derived numeric columns that capture\nmost of the information relating the explanatory columns to the\nspecified \"y\" or dependent/outcome column through a number of numeric\ntransforms (indicator variables, impact codes, prevalence codes, and\nmore).  This transformed DataFrame is suitable for a wide range of\nsupervised learning methods from linear regression, through gradient\nboosted machines.</p>\n\n<p>The idea is: you can take a DataFrame of messy real world data and\neasily, faithfully, reliably, and repeatably prepare it for machine\nlearning using documented methods using vtreat.  Incorporating\nvtreat into your machine learning workflow lets you quickly work\nwith very diverse structured data.</p>\n\n<p>Worked examples can be found <code>here</code><a href=\"https://github.com/WinVector/pyvtreat/tree/master/Examples\">https://github.com/WinVector/pyvtreat/tree/master/Examples</a>.</p>\n\n<p>For more detail please see here: <code>arXiv:1611.09477\nstat.AP</code><a href=\"https://arxiv.org/abs/1611.09477\">https://arxiv.org/abs/1611.09477</a> (the documentation describes the R version,\nhowever all of the examples can be found worked in Python \n<code>here</code><a href=\"https://github.com/WinVector/pyvtreat/tree/master/Examples/vtreat_paper1\">https://github.com/WinVector/pyvtreat/tree/master/Examples/vtreat_paper1</a>).</p>\n\n<p>vtreat is available\nas a <code>Python/Pandas package</code><a href=\"https://github.com/WinVector/vtreat\">https://github.com/WinVector/vtreat</a>,\nand also as an <code>R package</code><a href=\"https://github.com/WinVector/vtreat\">https://github.com/WinVector/vtreat</a>.</p>\n"}, {"fullname": "vtreat.cross_plan", "modulename": "vtreat.cross_plan", "qualname": "", "type": "module", "doc": "<p>Basic cross validation methods</p>\n"}, {"fullname": "vtreat.cross_plan.CrossValidationPlan", "modulename": "vtreat.cross_plan", "qualname": "CrossValidationPlan", "type": "class", "doc": "<p>Data splitting plan</p>\n"}, {"fullname": "vtreat.cross_plan.CrossValidationPlan.__init__", "modulename": "vtreat.cross_plan", "qualname": "CrossValidationPlan.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "vtreat.cross_plan.CrossValidationPlan.split_plan", "modulename": "vtreat.cross_plan", "qualname": "CrossValidationPlan.split_plan", "type": "function", "doc": "<p>Build a cross validation plan for the given parameters.</p>\n\n<p>:param n_rows: (optional) number of input rows\n:param k_folds: (optional) number of folds we want\n:param data: (optional) explanatory variables\n:param y: (optional) dependent variable\n:return: cross validation plan (list of dictionaries)</p>\n", "parameters": ["self", "n_rows", "k_folds", "data", "y"], "funcdef": "def"}, {"fullname": "vtreat.cross_plan.KWayCrossPlanYStratified", "modulename": "vtreat.cross_plan", "qualname": "KWayCrossPlanYStratified", "type": "class", "doc": "<p>K-way cross validation plan, attempting an even y-distribution</p>\n"}, {"fullname": "vtreat.cross_plan.KWayCrossPlanYStratified.__init__", "modulename": "vtreat.cross_plan", "qualname": "KWayCrossPlanYStratified.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "vtreat.cross_plan.KWayCrossPlanYStratified.split_plan", "modulename": "vtreat.cross_plan", "qualname": "KWayCrossPlanYStratified.split_plan", "type": "function", "doc": "<p>:param n_rows: required, number of rows\n:param k_folds: required, number of cross-folds\n:param data: not used\n:param y: required, outcomes to stratify on\n:return:</p>\n", "parameters": ["self", "n_rows", "k_folds", "data", "y"], "funcdef": "def"}, {"fullname": "vtreat.stats_utils", "modulename": "vtreat.stats_utils", "qualname": "", "type": "module", "doc": "<p>util for basic statistical steps</p>\n"}, {"fullname": "vtreat.stats_utils.our_corr_score", "modulename": "vtreat.stats_utils", "qualname": "our_corr_score", "type": "function", "doc": "<p>Compute Pearson correlation. Case-out some corner cases.</p>\n\n<p>:param y_true: truth values\n:param y_pred: predictions\n:return: (pearson r, significance)</p>\n", "parameters": ["y_true", "y_pred"], "funcdef": "def"}, {"fullname": "vtreat.stats_utils.est_deviance", "modulename": "vtreat.stats_utils", "qualname": "est_deviance", "type": "function", "doc": "<p>Estimate the deviance</p>\n\n<p>:param y: truth values\n:param est: predictions\n:param epsilon: how close to get to 0 and 1\n:return: deviance estimate</p>\n", "parameters": ["y", "est", "epsilon"], "funcdef": "def"}, {"fullname": "vtreat.stats_utils.sklearn_solve_logistic", "modulename": "vtreat.stats_utils", "qualname": "sklearn_solve_logistic", "type": "function", "doc": "<p>Single variable logistic regression.\nAssumes special cases of solve_logistic_regression already eliminated.</p>\n\n<p>:param y: dependent variable\n:param x: explanatory variable\n:param regularization:\n:return: model predictions</p>\n", "parameters": ["y", "x", "regularization"], "funcdef": "def"}, {"fullname": "vtreat.stats_utils.solve_logistic_regression", "modulename": "vtreat.stats_utils", "qualname": "solve_logistic_regression", "type": "function", "doc": "<p>Single variable logistic regression. Returns predictions, corner\ncases removed.</p>\n\n<p>:param y: dependent variable\n:param x: explanatory variable\n:return: predictions</p>\n", "parameters": ["y", "x"], "funcdef": "def"}, {"fullname": "vtreat.stats_utils.our_pseudo_R2", "modulename": "vtreat.stats_utils", "qualname": "our_pseudo_R2", "type": "function", "doc": "<p>Return the logistic pseudo-R2</p>\n\n<p>:param y_true: dependent variable\n:param y_pred: explanatory variable\n:return: (pseudo-R2, significance)</p>\n", "parameters": ["y_true", "y_pred"], "funcdef": "def"}, {"fullname": "vtreat.stats_utils.xicor", "modulename": "vtreat.stats_utils", "qualname": "xicor", "type": "function", "doc": "<p>xicor calculation built to match from R::caclulateXI() and published article.</p>\n\n<p>:param xvec: numeric vector with explanatory variable to compute xicor for.\n:param yvec: numeric dependent variable to relate to.\n:param n_reps: number of times to repeat calculation.\n:return: mean and standard error of estimate (under x-tie breaking)</p>\n", "parameters": ["xvec", "yvec", "n_reps"], "funcdef": "def"}, {"fullname": "vtreat.stats_utils.xicor_for_frame", "modulename": "vtreat.stats_utils", "qualname": "xicor_for_frame", "type": "function", "doc": "<p>Calculate xicor for all columns of data frame d with respect to dependent column y.</p>\n\n<p>:param d: data frame of proposed explanatory variables.\n:param y: vector of the dependent variable values.\n:param n_reps: number of times to repeat experiment (positive integer)\n:return: data frame with: variable (name of column), xicor (estimated xicor statistic),\n         xicor_se (standard error of xicor estimate, goes to zero as n_reps grows),\n         xicor_perm_mean (mean value of xicor with y scrambled, goes to zero as n_reps grows),\n         xicor_perm_stddev (sample standard deviation of y scrambled xicor estimates,\n         used to form z or t style estimates).</p>\n", "parameters": ["d", "y", "n_reps"], "funcdef": "def"}, {"fullname": "vtreat.transform", "modulename": "vtreat.transform", "qualname": "", "type": "module", "doc": "<p>base class for user transforms</p>\n"}, {"fullname": "vtreat.transform.UserTransform", "modulename": "vtreat.transform", "qualname": "UserTransform", "type": "class", "doc": "<p>base class for user transforms, should express taking a set of k inputs to k outputs independently</p>\n"}, {"fullname": "vtreat.transform.UserTransform.__init__", "modulename": "vtreat.transform", "qualname": "UserTransform.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "treatment"], "funcdef": "def"}, {"fullname": "vtreat.transform.UserTransform.fit", "modulename": "vtreat.transform", "qualname": "UserTransform.fit", "type": "function", "doc": "<p>sklearn API</p>\n\n<p>:param X: explanatory values\n:param y: dependent values\n:return: self for method chaining</p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "vtreat.transform.UserTransform.transform", "modulename": "vtreat.transform", "qualname": "UserTransform.transform", "type": "function", "doc": "<p>:param X: explanatory values\n:return: transformed data</p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "vtreat.transform.UserTransform.fit_transform", "modulename": "vtreat.transform", "qualname": "UserTransform.fit_transform", "type": "function", "doc": "<p>:param X: explanatory values\n:param y: dependent values\n:return: transformed data</p>\n", "parameters": ["self", "X", "y"], "funcdef": "def"}, {"fullname": "vtreat.util", "modulename": "vtreat.util", "qualname": "", "type": "module", "doc": "<p>Utility functions for vtreat</p>\n"}, {"fullname": "vtreat.util.safe_to_numeric_array", "modulename": "vtreat.util", "qualname": "safe_to_numeric_array", "type": "function", "doc": "<p>Convert array to numeric. Note, will parse strings (due to numpy)!</p>\n\n<p>:param x: array to process\n:return: numeric array</p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "vtreat.util.can_convert_v_to_numeric", "modulename": "vtreat.util", "qualname": "can_convert_v_to_numeric", "type": "function", "doc": "<p>check if non-empty vector can convert to numeric</p>\n\n<p>:param x:\n:return: True if can convert to numeric, false otherwise (no string parsing).</p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "vtreat.util.is_bad", "modulename": "vtreat.util", "qualname": "is_bad", "type": "function", "doc": "<p>For numeric vector x, return logical vector of positions that are null, NaN, infinite.</p>\n\n<p>:param x:\n:return:</p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "vtreat.util.numeric_has_range", "modulename": "vtreat.util", "qualname": "numeric_has_range", "type": "function", "doc": "<p>Check if a numeric vector has numeric range.</p>\n\n<p>:param x: vector to check\n:return: True if max &gt; min values in vector, else False.</p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "vtreat.util.summarize_column", "modulename": "vtreat.util", "qualname": "summarize_column", "type": "function", "doc": "<p>Summarize column to a non-missing scalar.</p>\n\n<p>:param x: a vector/Series or column of numbers\n:param fn: summarize function (such as numpy.mean), only passed non-bad positions\n:return: scalar float summary of the non-None positions of x (otherwise 0)</p>\n", "parameters": ["x", "fn"], "funcdef": "def"}, {"fullname": "vtreat.util.characterize_numeric", "modulename": "vtreat.util", "qualname": "characterize_numeric", "type": "function", "doc": "<p>compute na count, min,max,mean of a numeric vector</p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "vtreat.util.get_unique_value_count", "modulename": "vtreat.util", "qualname": "get_unique_value_count", "type": "function", "doc": "<p>compute how many unique values in list-x</p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "vtreat.util.grouped_by_x_statistics", "modulename": "vtreat.util", "qualname": "grouped_by_x_statistics", "type": "function", "doc": "<p>compute some grouped by x vector summaries of numeric y vector (no missing values in y)</p>\n", "parameters": ["x", "y"], "funcdef": "def"}, {"fullname": "vtreat.util.score_variables", "modulename": "vtreat.util", "qualname": "score_variables", "type": "function", "doc": "<p>score the linear relation of variables to outcome</p>\n", "parameters": ["cross_frame", "variables", "outcome", "is_classification"], "funcdef": "def"}, {"fullname": "vtreat.util.check_matching_numeric_frames", "modulename": "vtreat.util", "qualname": "check_matching_numeric_frames", "type": "function", "doc": "<p>Check if two numeric pandas.DataFrame s are identical.  assert if not\n:param res:\n:param expect:\n:param tol: numeric tolerance.\n:return: None</p>\n", "parameters": ["res", "expect", "tol"], "funcdef": "def"}, {"fullname": "vtreat.util.unique_items_in_order", "modulename": "vtreat.util", "qualname": "unique_items_in_order", "type": "function", "doc": "<p>Return de-duplicated list of items in order they are in supplied array.</p>\n\n<p>:param x: vector to inspect\n:return: list</p>\n", "parameters": ["x"], "funcdef": "def"}, {"fullname": "vtreat.util.clean_string", "modulename": "vtreat.util", "qualname": "clean_string", "type": "function", "doc": "<p>Replace common symbols with column-name safe alternatives.</p>\n\n<p>:param s: incoming string\n:return: string</p>\n", "parameters": ["s"], "funcdef": "def"}, {"fullname": "vtreat.util.build_level_codes", "modulename": "vtreat.util", "qualname": "build_level_codes", "type": "function", "doc": "<p>Pick level names for a set of levels.</p>\n\n<p>:param incoming_column_name:\n:param levels:\n:return:</p>\n", "parameters": ["incoming_column_name", "levels"], "funcdef": "def"}, {"fullname": "vtreat.util.hash_data_frame", "modulename": "vtreat.util", "qualname": "hash_data_frame", "type": "function", "doc": "<p>Get a hash code representing a data frame.</p>\n\n<p>:param d: data frame\n:return: hash code as a string</p>\n", "parameters": ["d"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_api", "modulename": "vtreat.vtreat_api", "qualname": "", "type": "module", "doc": "<p>Define user visible vtreat API.</p>\n"}, {"fullname": "vtreat.vtreat_api.vtreat_parameters", "modulename": "vtreat.vtreat_api", "qualname": "vtreat_parameters", "type": "function", "doc": "<p>build a vtreat parameters dictionary, adding in user choices</p>\n\n<p>:param user_params: dictionary of user choices\n:return: dictionary of user and default choices</p>\n", "parameters": ["user_params"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_api.unsupervised_parameters", "modulename": "vtreat.vtreat_api", "qualname": "unsupervised_parameters", "type": "function", "doc": "<p>build a vtreat parameters dictionary for unsupervised tasks, adding in user choices</p>\n\n<p>:param user_params: dictionary of user choices\n:return: dictionary of user and default choices</p>\n", "parameters": ["user_params"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_api.NumericOutcomeTreatment", "modulename": "vtreat.vtreat_api", "qualname": "NumericOutcomeTreatment", "type": "class", "doc": "<p>manage a treatment plan for a numeric outcome (regression)</p>\n"}, {"fullname": "vtreat.vtreat_api.NumericOutcomeTreatment.__init__", "modulename": "vtreat.vtreat_api", "qualname": "NumericOutcomeTreatment.__init__", "type": "function", "doc": "<p>:param var_list: list or tuple of column names, if empty all non outcome and copy columns are used\n:param outcome_name: name of column containing dependent variable\n:param cols_to_copy: list or tuple of column names\n:param params: vtreat.vtreat_parameters()\n:param imputation_map: map of column names to custom missing imputation values or functions</p>\n", "parameters": ["self", "var_list", "outcome_name", "cols_to_copy", "params", "imputation_map"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_api.NumericOutcomeTreatment.merge_params", "modulename": "vtreat.vtreat_api", "qualname": "NumericOutcomeTreatment.merge_params", "type": "function", "doc": "<p>Merge user parameters, returns new parameters does not alter object.</p>\n\n<p>:param p:\n:return: merged parameters</p>\n", "parameters": ["self", "p"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_api.NumericOutcomeTreatment.transform", "modulename": "vtreat.vtreat_api", "qualname": "NumericOutcomeTreatment.transform", "type": "function", "doc": "<p>Apply transform to data.</p>\n\n<p>:param X: data\n:return: transformed data</p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_api.NumericOutcomeTreatment.fit_transform", "modulename": "vtreat.vtreat_api", "qualname": "NumericOutcomeTreatment.fit_transform", "type": "function", "doc": "<p>fit_transform data, this is the way to fit with cross methods.</p>\n\n<p>:param X: explanatory values\n:param y: dependent values\n:param fit_params:\n:return: transformed data</p>\n", "parameters": ["self", "X", "y", "fit_params"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_api.BinomialOutcomeTreatment", "modulename": "vtreat.vtreat_api", "qualname": "BinomialOutcomeTreatment", "type": "class", "doc": "<p>manage a treatment plan for a target outcome (binomial classification)</p>\n"}, {"fullname": "vtreat.vtreat_api.BinomialOutcomeTreatment.__init__", "modulename": "vtreat.vtreat_api", "qualname": "BinomialOutcomeTreatment.__init__", "type": "function", "doc": "<p>:param var_list: list or tuple of column names, if empty all non outcome and copy columns are used\n:param outcome_name: name of column containing dependent variable\n:param outcome_target: value of outcome to consider \"positive\"\n:param cols_to_copy: list or tuple of column names\n:param params: vtreat.vtreat_parameters()\n:param imputation_map: map of column names to custom missing imputation values or functions</p>\n", "parameters": ["self", "var_list", "outcome_name", "outcome_target", "cols_to_copy", "params", "imputation_map"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_api.BinomialOutcomeTreatment.merge_params", "modulename": "vtreat.vtreat_api", "qualname": "BinomialOutcomeTreatment.merge_params", "type": "function", "doc": "<p>Merge user parameters, returns new parameters does not alter object.</p>\n\n<p>:param p:\n:return: merged parameters</p>\n", "parameters": ["self", "p"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_api.BinomialOutcomeTreatment.transform", "modulename": "vtreat.vtreat_api", "qualname": "BinomialOutcomeTreatment.transform", "type": "function", "doc": "<p>Apply transform to data.</p>\n\n<p>:param X: data\n:return: transformed data</p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_api.BinomialOutcomeTreatment.fit_transform", "modulename": "vtreat.vtreat_api", "qualname": "BinomialOutcomeTreatment.fit_transform", "type": "function", "doc": "<p>fit_transform data, this is the way to fit with cross methods.</p>\n\n<p>:param X: explanatory values\n:param y: dependent values\n:param fit_params:\n:return: transformed data</p>\n", "parameters": ["self", "X", "y", "fit_params"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_api.MultinomialOutcomeTreatment", "modulename": "vtreat.vtreat_api", "qualname": "MultinomialOutcomeTreatment", "type": "class", "doc": "<p>manage a treatment plan for a set of outcomes (multinomial classification)</p>\n"}, {"fullname": "vtreat.vtreat_api.MultinomialOutcomeTreatment.__init__", "modulename": "vtreat.vtreat_api", "qualname": "MultinomialOutcomeTreatment.__init__", "type": "function", "doc": "<p>:param var_list: list or tuple of column names, if empty all non outcome and copy columns are used\n:param outcome_name: name of column containing dependent variable\n:param cols_to_copy: list or tuple of column names\n:param params: vtreat.vtreat_parameters()\n:param imputation_map: map of column names to custom missing imputation values or functions</p>\n", "parameters": ["self", "var_list", "outcome_name", "cols_to_copy", "params", "imputation_map"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_api.MultinomialOutcomeTreatment.merge_params", "modulename": "vtreat.vtreat_api", "qualname": "MultinomialOutcomeTreatment.merge_params", "type": "function", "doc": "<p>Merge user parameters, returns new parameters does not alter object.</p>\n\n<p>:param p:\n:return: merged parameters</p>\n", "parameters": ["self", "p"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_api.MultinomialOutcomeTreatment.transform", "modulename": "vtreat.vtreat_api", "qualname": "MultinomialOutcomeTreatment.transform", "type": "function", "doc": "<p>Apply transform to data.</p>\n\n<p>:param X: data\n:return: transformed data</p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_api.MultinomialOutcomeTreatment.fit_transform", "modulename": "vtreat.vtreat_api", "qualname": "MultinomialOutcomeTreatment.fit_transform", "type": "function", "doc": "<p>fit_transform data, this is the way to fit with cross methods.</p>\n\n<p>:param X: explanatory values\n:param y: dependent values\n:param fit_params:\n:return: transformed data</p>\n", "parameters": ["self", "X", "y", "fit_params"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_api.UnsupervisedTreatment", "modulename": "vtreat.vtreat_api", "qualname": "UnsupervisedTreatment", "type": "class", "doc": "<p>manage an unsupervised treatment plan</p>\n"}, {"fullname": "vtreat.vtreat_api.UnsupervisedTreatment.__init__", "modulename": "vtreat.vtreat_api", "qualname": "UnsupervisedTreatment.__init__", "type": "function", "doc": "<p>:param var_list: list or tuple of column names, if empty all non copy columns are used\n:param cols_to_copy: list or tuple of column names\n:param params: vtreat.unsupervised_parameters()\n:param imputation_map: map of column names to custom missing imputation values or functions</p>\n", "parameters": ["self", "var_list", "cols_to_copy", "params", "imputation_map"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_api.UnsupervisedTreatment.merge_params", "modulename": "vtreat.vtreat_api", "qualname": "UnsupervisedTreatment.merge_params", "type": "function", "doc": "<p>Merge user parameters, returns new parameters does not alter object.</p>\n\n<p>:param p:\n:return: merged parameters</p>\n", "parameters": ["self", "p"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_api.UnsupervisedTreatment.transform", "modulename": "vtreat.vtreat_api", "qualname": "UnsupervisedTreatment.transform", "type": "function", "doc": "<p>Apply transform to data.</p>\n\n<p>:param X: data\n:return: transformed data</p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_api.UnsupervisedTreatment.fit_transform", "modulename": "vtreat.vtreat_api", "qualname": "UnsupervisedTreatment.fit_transform", "type": "function", "doc": "<p>fit_transform data.</p>\n\n<p>:param X: explanatory values\n:param y: dependent values\n:param fit_params:\n:return: transformed data</p>\n", "parameters": ["self", "X", "y", "fit_params"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_db_adapter", "modulename": "vtreat.vtreat_db_adapter", "qualname": "", "type": "module", "doc": "<p>Convert the description of a vtreat variable treatment into a data algebra pipeline.</p>\n"}, {"fullname": "vtreat.vtreat_db_adapter.as_data_algebra_pipeline", "modulename": "vtreat.vtreat_db_adapter", "qualname": "as_data_algebra_pipeline", "type": "function", "doc": "<p>Convert the description of a vtreat transform (gotten via .description_matrix())\ninto a data algebra pipeline.\nSee: https://github.com/WinVector/data_algebra and https://github.com/WinVector/pyvtreat .\nMissing and nan are treated as synonyms for '_NA_'.\nAssembling the entire pipeline can be expensive. If one is willing to instantiate tables\nit can be better to sequence operations instead of composing them.\nAnother way to use this methodology would be to port this code as a stored procedure\nin a target database of choice, meaning only the vtreat_descr table would be needed on such systems.</p>\n\n<p>:param source: input data.\n:param vtreat_descr: .description_matrix() description of transform.\n                     Expected invariant: CleanNumericTransform doesn't change variable names,\n                     all other operations produce new names.\n:param treatment_table_name: name to use for the vtreat_descr table.\n:param row_keys: list of columns uniquely keying rows\n:return: data algebra pipeline implementing specified vtreat treatment</p>\n", "parameters": ["source", "vtreat_descr", "treatment_table_name", "row_keys"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl", "modulename": "vtreat.vtreat_impl", "qualname": "", "type": "module", "doc": "<p>vtreat main implementation</p>\n"}, {"fullname": "vtreat.vtreat_impl.replace_bad_with_sentinel", "modulename": "vtreat.vtreat_impl", "qualname": "replace_bad_with_sentinel", "type": "function", "doc": "<p>Replace None/NaN entries in iterable with '_NA_'\n:param ar: iterable\n:return: one dimensional numpy array</p>\n", "parameters": ["ar"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.ready_data_frame", "modulename": "vtreat.vtreat_impl", "qualname": "ready_data_frame", "type": "function", "doc": "<p>Convert an array-like object to a data frame for processing.</p>\n\n<p>:param d: data frame like object to work with\n:return: dataframe with string-named columns</p>\n", "parameters": ["d"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.back_to_orig_type_data_frame", "modulename": "vtreat.vtreat_impl", "qualname": "back_to_orig_type_data_frame", "type": "function", "doc": "<p>Convert data frame back to ndarray if that was the original type.</p>\n\n<p>:param d: data frame\n:param orig_type: type of original object\n:return: converted result</p>\n", "parameters": ["d", "orig_type"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.VarTransform", "modulename": "vtreat.vtreat_impl", "qualname": "VarTransform", "type": "class", "doc": "<p>Base class for vtreat transforms</p>\n"}, {"fullname": "vtreat.vtreat_impl.VarTransform.__init__", "modulename": "vtreat.vtreat_impl", "qualname": "VarTransform.__init__", "type": "function", "doc": "<p>:param incoming_column_name:\n:param incoming_column_is_numeric:\n:param derived_column_names:\n:param treatment:</p>\n", "parameters": ["self", "incoming_column_name", "incoming_column_is_numeric", "derived_column_names", "treatment"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.VarTransform.transform", "modulename": "vtreat.vtreat_impl", "qualname": "VarTransform.transform", "type": "function", "doc": "<p>return a transformed data frame</p>\n\n<p>:rtype: pandas.DataFrame\n:param data_frame: incoming values\n:return: transformed values</p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.VarTransform.description_matrix", "modulename": "vtreat.vtreat_impl", "qualname": "VarTransform.description_matrix", "type": "function", "doc": "<p>Return description of transform as a data frame.</p>\n\n<p>:return: description of transform.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.TreatmentPlan", "modulename": "vtreat.vtreat_impl", "qualname": "TreatmentPlan", "type": "class", "doc": "<p>Class to carry treatment plans.</p>\n"}, {"fullname": "vtreat.vtreat_impl.TreatmentPlan.__init__", "modulename": "vtreat.vtreat_impl", "qualname": "TreatmentPlan.__init__", "type": "function", "doc": "<p></p>\n", "parameters": ["self", "outcome_name", "cols_to_copy", "num_list", "cat_list", "xforms"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.MappedCodeTransform", "modulename": "vtreat.vtreat_impl", "qualname": "MappedCodeTransform", "type": "class", "doc": "<p>Class for transforms that are a dictionary mapping of strings to numeric values</p>\n"}, {"fullname": "vtreat.vtreat_impl.MappedCodeTransform.__init__", "modulename": "vtreat.vtreat_impl", "qualname": "MappedCodeTransform.__init__", "type": "function", "doc": "<p>:param incoming_column_name:\n:param derived_column_name:\n:param treatment:\n:param code_book: Pandas dataframe mapping values to impact codes</p>\n", "parameters": ["self", "incoming_column_name", "derived_column_name", "treatment", "code_book"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.MappedCodeTransform.transform", "modulename": "vtreat.vtreat_impl", "qualname": "MappedCodeTransform.transform", "type": "function", "doc": "<p>return a transformed data frame</p>\n\n<p>:rtype: pandas.DataFrame\n:param data_frame: incoming values\n:return: transformed values</p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.MappedCodeTransform.description_matrix", "modulename": "vtreat.vtreat_impl", "qualname": "MappedCodeTransform.description_matrix", "type": "function", "doc": "<p>Return description of transform as a data frame.</p>\n\n<p>:return: description of transform.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.YAwareMappedCodeTransform", "modulename": "vtreat.vtreat_impl", "qualname": "YAwareMappedCodeTransform", "type": "class", "doc": "<p>Class for transforms that are a y-aware dictionary mapping of values</p>\n"}, {"fullname": "vtreat.vtreat_impl.YAwareMappedCodeTransform.__init__", "modulename": "vtreat.vtreat_impl", "qualname": "YAwareMappedCodeTransform.__init__", "type": "function", "doc": "<p>:param incoming_column_name: name of incoming column\n:param derived_column_name: name of incoming column\n:param treatment: name of treatment\n:param code_book: pandas data frame mapping values to codes\n:param refitter: function to re-fit\n:param extra_args: extra args for fit_* functions\n:param params: configuration control parameters</p>\n", "parameters": ["self", "incoming_column_name", "derived_column_name", "treatment", "code_book", "refitter", "extra_args", "params"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.CleanNumericTransform", "modulename": "vtreat.vtreat_impl", "qualname": "CleanNumericTransform", "type": "class", "doc": "<p>Class for numeric column cleaner.</p>\n"}, {"fullname": "vtreat.vtreat_impl.CleanNumericTransform.__init__", "modulename": "vtreat.vtreat_impl", "qualname": "CleanNumericTransform.__init__", "type": "function", "doc": "<p>:param incoming_column_name:\n:param replacement_value:</p>\n", "parameters": ["self", "incoming_column_name", "replacement_value"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.CleanNumericTransform.transform", "modulename": "vtreat.vtreat_impl", "qualname": "CleanNumericTransform.transform", "type": "function", "doc": "<p>return a transformed data frame</p>\n\n<p>:rtype: pandas.DataFrame\n:param data_frame: incoming values\n:return: transformed values</p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.CleanNumericTransform.description_matrix", "modulename": "vtreat.vtreat_impl", "qualname": "CleanNumericTransform.description_matrix", "type": "function", "doc": "<p>Return description of transform as a data frame.</p>\n\n<p>:return: description of transform.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.IndicateMissingTransform", "modulename": "vtreat.vtreat_impl", "qualname": "IndicateMissingTransform", "type": "class", "doc": "<p>Class for missing value indicator.</p>\n"}, {"fullname": "vtreat.vtreat_impl.IndicateMissingTransform.__init__", "modulename": "vtreat.vtreat_impl", "qualname": "IndicateMissingTransform.__init__", "type": "function", "doc": "<p>:param incoming_column_name:\n:param derived_column_name:</p>\n", "parameters": ["self", "incoming_column_name", "incoming_column_is_numeric", "derived_column_name"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.IndicateMissingTransform.transform", "modulename": "vtreat.vtreat_impl", "qualname": "IndicateMissingTransform.transform", "type": "function", "doc": "<p>return a transformed data frame</p>\n\n<p>:rtype: pandas.DataFrame\n:param data_frame: incoming values\n:return: transformed values</p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.IndicateMissingTransform.description_matrix", "modulename": "vtreat.vtreat_impl", "qualname": "IndicateMissingTransform.description_matrix", "type": "function", "doc": "<p>Return description of transform as a data frame.</p>\n\n<p>:return: description of transform.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.fit_clean_code", "modulename": "vtreat.vtreat_impl", "qualname": "fit_clean_code", "type": "function", "doc": "<p>Fit numeric clean column imputation transform</p>\n\n<p>:param incoming_column_name: name of column\n:param x: training values for column\n:param params: control parameter dictionary\n:param imputation_map: per-column map to imputation strategies or values\n:return: transform</p>\n", "parameters": ["incoming_column_name", "x", "params", "imputation_map"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.fit_regression_impact_code", "modulename": "vtreat.vtreat_impl", "qualname": "fit_regression_impact_code", "type": "function", "doc": "<p>Fit regression impact code transform</p>\n\n<p>:param incoming_column_name:\n:param x: training explanatory values\n:param y: training dependent values\n:param extra_args: optional extra arguments for fit_ methods\n:param params: control parameter dictionary\n:return:</p>\n", "parameters": ["incoming_column_name", "x", "y", "extra_args", "params"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.fit_regression_deviation_code", "modulename": "vtreat.vtreat_impl", "qualname": "fit_regression_deviation_code", "type": "function", "doc": "<p>Fit regression deviation code transform</p>\n\n<p>:param incoming_column_name:\n:param x: training explanatory values\n:param y: training dependent values\n:param extra_args: optional extra arguments for fit_ methods\n:param params: control parameter dictionary\n:return:</p>\n", "parameters": ["incoming_column_name", "x", "y", "extra_args", "params"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.fit_binomial_impact_code", "modulename": "vtreat.vtreat_impl", "qualname": "fit_binomial_impact_code", "type": "function", "doc": "<p>Fit categorical impact code.</p>\n\n<p>:param incoming_column_name:\n:param x: training explanatory values\n:param y: training dependent values\n:param extra_args: required extra arguments for fit_ methods\n:param params: control parameter dictionary\n:return:</p>\n", "parameters": ["incoming_column_name", "x", "y", "extra_args", "params"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.IndicatorCodeTransform", "modulename": "vtreat.vtreat_impl", "qualname": "IndicatorCodeTransform", "type": "class", "doc": "<p>Class for indicator codes</p>\n"}, {"fullname": "vtreat.vtreat_impl.IndicatorCodeTransform.__init__", "modulename": "vtreat.vtreat_impl", "qualname": "IndicatorCodeTransform.__init__", "type": "function", "doc": "<p>:param incoming_column_name:\n:param derived_column_names:\n:param levels: leves we are encoding to indicators\n:param sparse_indicators: if True use sparse data structure</p>\n", "parameters": ["self", "incoming_column_name", "derived_column_names", "levels", "sparse_indicators"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.IndicatorCodeTransform.transform", "modulename": "vtreat.vtreat_impl", "qualname": "IndicatorCodeTransform.transform", "type": "function", "doc": "<p>return a transformed data frame</p>\n\n<p>:rtype: pandas.DataFrame\n:param data_frame: incoming values\n:return: transformed values</p>\n", "parameters": ["self", "data_frame"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.IndicatorCodeTransform.description_matrix", "modulename": "vtreat.vtreat_impl", "qualname": "IndicatorCodeTransform.description_matrix", "type": "function", "doc": "<p>Return description of transform as a data frame.</p>\n\n<p>:return: description of transform.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.fit_indicator_code", "modulename": "vtreat.vtreat_impl", "qualname": "fit_indicator_code", "type": "function", "doc": "<p>Fit indicator codes</p>\n\n<p>:param incoming_column_name:\n:param x: training explanatory variables\n:param min_fraction:\n:param max_levels:\n:param sparse_indicators:\n:return:</p>\n", "parameters": ["incoming_column_name", "x", "min_fraction", "max_levels", "sparse_indicators"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.fit_prevalence_code", "modulename": "vtreat.vtreat_impl", "qualname": "fit_prevalence_code", "type": "function", "doc": "<p>Fit a prevalence code</p>\n\n<p>:param incoming_column_name:\n:param x: training explanatory values\n:return:</p>\n", "parameters": ["incoming_column_name", "x"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.fit_numeric_outcome_treatment", "modulename": "vtreat.vtreat_impl", "qualname": "fit_numeric_outcome_treatment", "type": "function", "doc": "<p>Fit set of treatments in a regression situation.</p>\n\n<p>:param X: training explanatory values\n:param y: training dependent values\n:param var_list: list of dependent variable names, if empty all non outcome and copy columns are used\n:param outcome_name: name for outcome column\n:param cols_to_copy: list of columns to copy to output\n:param params: control parameter dictionary\n:param imputation_map: per-column map to imputation strategies or values\n:return: transform plan</p>\n", "parameters": ["X", "y", "var_list", "outcome_name", "cols_to_copy", "params", "imputation_map"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.fit_binomial_outcome_treatment", "modulename": "vtreat.vtreat_impl", "qualname": "fit_binomial_outcome_treatment", "type": "function", "doc": "<p>:param X: training explanatory values\n:param y: training dependent values\n:param outcome_target: dependent value to consider positive or in class\n:param var_list: list of variables to process, if empty all non outcome and copy columns are used\n:param outcome_name: name for outcome column\n:param cols_to_copy: list of columns to copy to output\n:param params: control parameter dictionary\n:param imputation_map: per-column map to imputation strategies or values\n:return: transform plan</p>\n", "parameters": ["X", "y", "outcome_target", "var_list", "outcome_name", "cols_to_copy", "params", "imputation_map"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.fit_multinomial_outcome_treatment", "modulename": "vtreat.vtreat_impl", "qualname": "fit_multinomial_outcome_treatment", "type": "function", "doc": "<p>Fit a variable treatment for multinomial outcomes.</p>\n\n<p>:param X: training explanatory values\n:param y: training dependent values\n:param var_list: list of variables to process, if empty all non outcome and copy columns are used\n:param outcome_name: name for outcome column\n:param cols_to_copy: list of columns to copy to output\n:param params: control parameter dictionary\n:param imputation_map: per-column map to imputation strategies or values\n:return:</p>\n", "parameters": ["X", "y", "var_list", "outcome_name", "cols_to_copy", "params", "imputation_map"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.fit_unsupervised_treatment", "modulename": "vtreat.vtreat_impl", "qualname": "fit_unsupervised_treatment", "type": "function", "doc": "<p>Fit a data treatment in the unsupervised case.</p>\n\n<p>:param X: training explanatory values\n:param var_list: list of variables to process, if empty all non copy columns are used\n:param outcome_name: name for outcome column\n:param cols_to_copy: list of columns to copy to output\n:param params: control parameter dictionary\n:param imputation_map: per-column map to imputation strategies or values\n:return:</p>\n", "parameters": ["X", "var_list", "outcome_name", "cols_to_copy", "params", "imputation_map"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.pre_prep_frame", "modulename": "vtreat.vtreat_impl", "qualname": "pre_prep_frame", "type": "function", "doc": "<p>Create a copy of pandas.DataFrame x restricted to col_list union cols_to_copy with col_list - cols_to_copy\nconverted to only string and numeric types.  New pandas.DataFrame has trivial indexing.  If col_list\nis empty it is interpreted as all columns.</p>\n\n<p>:param x:\n:param col_list:\n:param cols_to_copy:\n:param cat_cols:\n:return:</p>\n", "parameters": ["x", "col_list", "cols_to_copy", "cat_cols"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.cross_patch_refit_y_aware_cols", "modulename": "vtreat.vtreat_impl", "qualname": "cross_patch_refit_y_aware_cols", "type": "function", "doc": "<p>Re fit the y-aware columns according to cross plan.\nClears out refitter_ values to None.\nAssumes each y-aware variable produces one derived column.</p>\n\n<p>:param x: explanatory values\n:param y: dependent values\n:param res: transformed frame to patch results into, altered\n:param plan: fitting plan\n:param cross_plan: cross validation plan\n:return: no return, res is altered in place</p>\n", "parameters": ["x", "y", "res", "plan", "cross_plan"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.cross_patch_user_y_aware_cols", "modulename": "vtreat.vtreat_impl", "qualname": "cross_patch_user_y_aware_cols", "type": "function", "doc": "<p>Re fit the user y-aware columns according to cross plan.\nAssumes each y-aware variable produces one derived column.</p>\n\n<p>:param x: explanatory values\n:param y: dependent values\n:param res: transformed frame to patch results into, altered\n:param params: control parameter dictionary\n:param cross_plan: cross validation plan\n:return: no return, res altered in place</p>\n", "parameters": ["x", "y", "res", "params", "cross_plan"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.score_plan_variables", "modulename": "vtreat.vtreat_impl", "qualname": "score_plan_variables", "type": "function", "doc": "<p>Quality score variables to build up score frame.</p>\n\n<p>:param cross_frame: cross transformed explanatory variables\n:param outcome: dependent variable\n:param plan: treatment plan\n:param params: control parameter dictionary\n:param is_classification: logical, if True classification if False regression\n:return: score frame</p>\n", "parameters": ["cross_frame", "outcome", "plan", "params", "is_classification"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.pseudo_score_plan_variables", "modulename": "vtreat.vtreat_impl", "qualname": "pseudo_score_plan_variables", "type": "function", "doc": "<p>Build a score frame look-alike for unsupervised case.</p>\n\n<p>:param cross_frame: cross transformed explanatory variables\n:param plan: treatment plan\n:param params: control parameter dictionary\n:return: score frame</p>\n", "parameters": ["cross_frame", "plan", "params"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.VariableTreatment", "modulename": "vtreat.vtreat_impl", "qualname": "VariableTreatment", "type": "class", "doc": "<p>Class for variable treatments, implements much of the sklearn pipeline/transformer\nAPI. https://sklearn-template.readthedocs.io/en/latest/user_guide.html#transformer</p>\n"}, {"fullname": "vtreat.vtreat_impl.VariableTreatment.__init__", "modulename": "vtreat.vtreat_impl", "qualname": "VariableTreatment.__init__", "type": "function", "doc": "<p>:param var_list: variables we intend to encode, empty means all\n:param outcome_name: column name of outcome\n:param outcome_target: outcome column value we consider in class or True\n:param cols_to_copy: columns to not process, but copy over\n:param params: control and configuration parameters\n:param imputation_map: per column imputation strategies or values</p>\n", "parameters": ["self", "var_list", "outcome_name", "outcome_target", "cols_to_copy", "params", "imputation_map"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.VariableTreatment.check_column_names", "modulename": "vtreat.vtreat_impl", "qualname": "VariableTreatment.check_column_names", "type": "function", "doc": "<p>Check that none of the column names we are working with are non-unique.\nAlso check variable columns are all present (columns to copy and outcome allowed to be missing).</p>\n\n<p>:param col_names:\n:return: None, raises exception if there is a problem</p>\n", "parameters": ["self", "col_names"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.VariableTreatment.clear", "modulename": "vtreat.vtreat_impl", "qualname": "VariableTreatment.clear", "type": "function", "doc": "<p>reset state</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.VariableTreatment.get_result_restriction", "modulename": "vtreat.vtreat_impl", "qualname": "VariableTreatment.get_result_restriction", "type": "function", "doc": "<p>accessor</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.VariableTreatment.set_result_restriction", "modulename": "vtreat.vtreat_impl", "qualname": "VariableTreatment.set_result_restriction", "type": "function", "doc": "<p>setter</p>\n", "parameters": ["self", "new_vars"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.VariableTreatment.merge_params", "modulename": "vtreat.vtreat_impl", "qualname": "VariableTreatment.merge_params", "type": "function", "doc": "<p>merge in use parameters</p>\n", "parameters": ["self", "p"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.VariableTreatment.fit", "modulename": "vtreat.vtreat_impl", "qualname": "VariableTreatment.fit", "type": "function", "doc": "<p>sklearn fit.</p>\n\n<p>:param X: explanatory variables\n:param y: (optional) dependent variable\n:param fit_params:\n:return: self (for method chaining)</p>\n", "parameters": ["self", "X", "y", "fit_params"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.VariableTreatment.fit_transform", "modulename": "vtreat.vtreat_impl", "qualname": "VariableTreatment.fit_transform", "type": "function", "doc": "<p>sklearn fit_transform, correct way to trigger cross methods.</p>\n\n<p>:param X: explanatory variables\n:param y: (optional) dependent variable\n:param fit_params:\n:return: transformed data</p>\n", "parameters": ["self", "X", "y", "fit_params"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.VariableTreatment.transform", "modulename": "vtreat.vtreat_impl", "qualname": "VariableTreatment.transform", "type": "function", "doc": "<p>sklearn transform</p>\n\n<p>:param X: explanatory variables\n:return: transformed data</p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.VariableTreatment.get_params", "modulename": "vtreat.vtreat_impl", "qualname": "VariableTreatment.get_params", "type": "function", "doc": "<p>vtreat exposes a subset of controls as tunable parameters, users can choose this set\nby specifying the tunable_params list in object construction parameters</p>\n\n<p>:param deep: ignored\n:return: dict of tunable parameters</p>\n", "parameters": ["self", "deep"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.VariableTreatment.set_params", "modulename": "vtreat.vtreat_impl", "qualname": "VariableTreatment.set_params", "type": "function", "doc": "<p>vtreat exposes a subset of controls as tunable parameters, users can choose this set\nby specifying the tunable_params list in object construction parameters</p>\n\n<p>:param params:\n:return: self (for method chaining)</p>\n", "parameters": ["self", "params"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.VariableTreatment.fit_predict", "modulename": "vtreat.vtreat_impl", "qualname": "VariableTreatment.fit_predict", "type": "function", "doc": "<p>Alias for fit_transform()</p>\n\n<p>:param X: explanatory variables\n:param y: (optional) dependent variable\n:param fit_params:\n:return: transformed data</p>\n", "parameters": ["self", "X", "y", "fit_params"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.VariableTreatment.predict", "modulename": "vtreat.vtreat_impl", "qualname": "VariableTreatment.predict", "type": "function", "doc": "<p>Alias for transform.</p>\n\n<p>:param X: explanatory variables\n:return: transformed data</p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.VariableTreatment.predict_proba", "modulename": "vtreat.vtreat_impl", "qualname": "VariableTreatment.predict_proba", "type": "function", "doc": "<p>Alias for transform.</p>\n\n<p>:param X: explanatory variables\n:return: transformed data</p>\n", "parameters": ["self", "X"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.VariableTreatment.get_feature_names", "modulename": "vtreat.vtreat_impl", "qualname": "VariableTreatment.get_feature_names", "type": "function", "doc": "<p>Get list of produced feature names.</p>\n\n<p>:param input_features: Optional, restrict to these features\n:return:</p>\n", "parameters": ["self", "input_features"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.VariableTreatment.description_matrix", "modulename": "vtreat.vtreat_impl", "qualname": "VariableTreatment.description_matrix", "type": "function", "doc": "<p>Return description of transform as a data frame. Does not encode user steps. Not yet implemented for\nmultinomial dependent variables.</p>\n\n<p>:return: description of transform.</p>\n", "parameters": ["self"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.perform_transform", "modulename": "vtreat.vtreat_impl", "qualname": "perform_transform", "type": "function", "doc": "<p>Transform a data frame.</p>\n\n<p>:param x: data to be transformed.\n:param transform: transform\n:param params: control parameter dictionary\n:return: new data frame</p>\n", "parameters": ["x", "transform", "params"], "funcdef": "def"}, {"fullname": "vtreat.vtreat_impl.limit_to_appropriate_columns", "modulename": "vtreat.vtreat_impl", "qualname": "limit_to_appropriate_columns", "type": "function", "doc": "<p>Limit down to appropriate columns.</p>\n\n<p>:param res:\n:param transform:\n:return:</p>\n", "parameters": ["res", "transform"], "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.addField("qualname");
            this.addField("fullname");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();